<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Tennis Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #eee;
    }
    h1 {
      font-size: 2rem;
      letter-spacing: 0.3em;
      margin-bottom: 12px;
      color: #f0c040;
      text-shadow: 0 0 10px #f0c04088;
    }
    #info {
      font-size: 0.85rem;
      color: #aaa;
      margin-bottom: 16px;
      letter-spacing: 0.1em;
    }
    canvas {
      background: #16213e;
      border: 3px solid #f0c040;
      border-radius: 4px;
      box-shadow: 0 0 30px #f0c04044;
      max-width: 100%;
      touch-action: none;
    }
    #touch-controls {
      display: none;
      margin-top: 12px;
      gap: 16px;
    }
    @media (pointer: coarse) {
      #touch-controls { display: flex; }
    }
    .touch-btn {
      background: rgba(240,192,64,0.2);
      border: 2px solid #f0c040;
      color: #f0c040;
      font-size: 2rem;
      width: 70px;
      height: 70px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }
    .touch-btn:active {
      background: rgba(240,192,64,0.4);
    }
    #message {
      margin-top: 14px;
      font-size: 1rem;
      color: #f0c040;
      letter-spacing: 0.15em;
      min-height: 1.4em;
    }
  </style>
</head>
<body>
  <h1>TENNIS</h1>
  <div id="info">ãƒã‚¦ã‚¹: è‡ªç”±ç§»å‹• &nbsp;|&nbsp; W/A/S/Dãƒ»çŸ¢å°ã‚­ãƒ¼: ç§»å‹• &nbsp;|&nbsp; SPACE: ã‚¹ã‚¿ãƒ¼ãƒˆ &nbsp;|&nbsp; ã‚¿ãƒƒãƒ: ç”»é¢ã‚’ãªãã‚‹</div>
  <canvas id="court" width="800" height="500"></canvas>
  <div id="message">SPACE ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯ã‚¿ãƒƒãƒ—ï¼‰</div>
  <div id="touch-controls">
    <div class="touch-btn" id="btn-up">â–²</div>
    <div class="touch-btn" id="btn-down">â–¼</div>
  </div>

  <script>
    const canvas = document.getElementById('court');
    const ctx = canvas.getContext('2d');
    const msg = document.getElementById('message');

    const W = canvas.width;
    const H = canvas.height;

    // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
    const PADDLE_W = 14;
    const PADDLE_H = 90;
    const BALL_R = 9;
    const PADDLE_SPEED = 6;
    const WIN_SCORE = 7;
    const NET_W = 4;

    // --- ã‚¹ãƒ†ãƒ¼ã‚¸å®šç¾© ---
    const OPPONENTS = [
      { name: 'ãƒã‚ºãƒŸ',   emoji: 'ğŸ­', color: '#ccc',  speed: 2.5,  freedom: 0    },
      { name: 'çŒ«',       emoji: 'ğŸ±', color: '#faa',  speed: 3.2,  freedom: 0    },
      { name: 'å¤§å‹çŠ¬',   emoji: 'ğŸ•', color: '#ca7',  speed: 4.0,  freedom: 0    },
      { name: 'ã‚¤ãƒã‚·ã‚·', emoji: 'ğŸ—', color: '#b97',  speed: 4.8,  freedom: 0.2  },
      { name: 'ãƒ ãƒ¼ã‚¹',   emoji: 'ğŸ«', color: '#8c6',  speed: 5.5,  freedom: 0.4  },
      { name: 'è™',       emoji: 'ğŸ¯', color: '#fb4',  speed: 6.2,  freedom: 0.55 },
      { name: 'ãƒ©ã‚¤ã‚ªãƒ³', emoji: 'ğŸ¦', color: '#e84',  speed: 7.0,  freedom: 0.65 },
      { name: 'ã‚¾ã‚¦',     emoji: 'ğŸ˜', color: '#aaa',  speed: 7.8,  freedom: 0.75 },
      { name: 'T-REX',    emoji: 'ğŸ¦–', color: '#5c9',  speed: 9.0,  freedom: 0.88 },
      { name: 'å®‡å®™äºº',   emoji: 'ğŸ‘½', color: '#8f8',  speed: 11.0, freedom: 1.0  },
    ];

    // --- çŠ¶æ…‹ ---
    let state = 'idle'; // idle | playing | point | stageclear | allclear | gameover
    let keys = {};
    let currentStage = 0;

    let player, cpu, ball, scores;

    function resetGame() {
      currentStage = 0;
      scores = { player: 0, cpu: 0 };
      resetRound(null);
      state = 'idle';
      msg.textContent = 'SPACE ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ';
    }

    function resetRound(scorer) {
      player = { x: 20, y: H / 2 - PADDLE_H / 2, w: PADDLE_W, h: PADDLE_H, dy: 0 };
      cpu    = { x: W - 20 - PADDLE_W, y: H / 2 - PADDLE_H / 2, w: PADDLE_W, h: PADDLE_H, dy: 0 };

      const dir = scorer === 'cpu' ? 1 : -1; // ã‚µãƒ¼ãƒ–æ–¹å‘
      const angle = (Math.random() * 0.6 - 0.3); // Â±0.3 rad
      const speed = 5.5;
      ball = {
        x: W / 2, y: H / 2,
        vx: dir * speed * Math.cos(angle),
        vy: speed * Math.sin(angle),
        trail: []
      };
    }

    // --- æç”» ---
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // ã‚³ãƒ¼ãƒˆèƒŒæ™¯
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, 0, W, H);

      // ã‚³ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³
      drawCourtLines();

      // ãƒãƒƒãƒˆ
      drawNet();

      // æ•µã‚­ãƒ£ãƒ©è¡¨ç¤ºï¼ˆèƒŒæ™¯ï¼‰
      drawOpponent();

      // ãƒœãƒ¼ãƒ«ã®è»Œè·¡
      drawTrail();

      // ãƒ‘ãƒ‰ãƒ«
      drawPaddle(player, '#4ecdc4');
      drawPaddle(cpu, OPPONENTS[currentStage].color);

      // ãƒœãƒ¼ãƒ«
      drawBall();

      // ã‚¹ã‚³ã‚¢
      drawScore();
    }

    function drawCourtLines() {
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 2;
      // å¤–æ 
      ctx.strokeRect(10, 10, W - 20, H - 20);
      // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³ï¼ˆä¸Šä¸‹ï¼‰
      ctx.beginPath();
      ctx.moveTo(W / 2, 10);
      ctx.lineTo(W / 2, H - 10);
      ctx.stroke();
    }

    function drawNet() {
      const x = W / 2 - NET_W / 2;
      const dashH = 16;
      const gap = 8;
      ctx.fillStyle = 'rgba(240,192,64,0.55)';
      for (let y = 10; y < H - 10; y += dashH + gap) {
        ctx.fillRect(x, y, NET_W, Math.min(dashH, H - 10 - y));
      }
    }

    function drawTrail() {
      ball.trail.forEach((p, i) => {
        const alpha = (i / ball.trail.length) * 0.4;
        const r = BALL_R * (i / ball.trail.length);
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,220,80,${alpha})`;
        ctx.fill();
      });
    }

    function drawPaddle(p, color) {
      const radius = 6;
      ctx.beginPath();
      ctx.roundRect(p.x, p.y, p.w, p.h, radius);
      ctx.fillStyle = color;
      ctx.shadowBlur = 12;
      ctx.shadowColor = color;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      const grad = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 1, ball.x, ball.y, BALL_R);
      grad.addColorStop(0, '#fffbe0');
      grad.addColorStop(1, '#f0c040');
      ctx.fillStyle = grad;
      ctx.shadowBlur = 16;
      ctx.shadowColor = '#f0c040';
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawScore() {
      const opp = OPPONENTS[currentStage];

      // ã‚¹ãƒ†ãƒ¼ã‚¸ç•ªå·ï¼ˆä¸­å¤®ä¸Šéƒ¨ï¼‰
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#f0c040';
      ctx.fillText(`STAGE  ${currentStage + 1} / ${OPPONENTS.length}`, W / 2, 22);

      // ã‚¹ã‚³ã‚¢æ•°å­—
      ctx.font = 'bold 48px Courier New';
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillText(scores.player, W / 4, 70);
      ctx.fillText(scores.cpu,    W * 3 / 4, 70);

      ctx.fillStyle = '#fff';
      ctx.fillText(scores.player, W / 4, 68);
      ctx.fillText(scores.cpu,    W * 3 / 4, 68);

      // ãƒ©ãƒ™ãƒ«
      ctx.font = '13px Courier New';
      ctx.fillStyle = '#4ecdc4';
      ctx.fillText('PLAYER', W / 4, 90);
      ctx.fillStyle = opp.color;
      ctx.fillText(opp.name, W * 3 / 4, 90);
    }

    function drawOpponent() {
      const opp = OPPONENTS[currentStage];
      // å³åŠã‚³ãƒ¼ãƒˆã«å¤§ããªçµµæ–‡å­—ã‚’åŠé€æ˜ã§è¡¨ç¤º
      ctx.save();
      ctx.font = '110px serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.38;
      ctx.fillStyle = '#fff';
      ctx.fillText(opp.emoji, W * 3 / 4, H / 2 + 45);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // --- æ›´æ–° ---
    function update() {
      if (state !== 'playing') return;

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼‰
      if (keys['w'] || keys['W'] || keys['ArrowUp']) {
        player.y -= PADDLE_SPEED;
      }
      if (keys['s'] || keys['S'] || keys['ArrowDown']) {
        player.y += PADDLE_SPEED;
      }
      if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
        player.x -= PADDLE_SPEED;
      }
      if (keys['d'] || keys['D'] || keys['ArrowRight']) {
        player.x += PADDLE_SPEED;
      }
      // ã‚¿ãƒƒãƒæ“ä½œ: æŒ‡ã®ä½ç½®ã«ãƒ‘ãƒ‰ãƒ«ä¸­å¿ƒã‚’è¿½å¾“
      if (touchPos !== null) {
        const targetX = touchPos.x - PADDLE_W / 2;
        const targetY = touchPos.y - PADDLE_H / 2;
        player.x += clamp(targetX - player.x, -PADDLE_SPEED * 2, PADDLE_SPEED * 2);
        player.y += clamp(targetY - player.y, -PADDLE_SPEED * 2, PADDLE_SPEED * 2);
      }
      // å·¦åŠã‚³ãƒ¼ãƒˆå†…ã«åˆ¶é™
      player.x = clamp(player.x, 5, W / 2 - PADDLE_W);
      player.y = clamp(player.y, 0, H - PADDLE_H);

      // CPU AIï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥é€Ÿåº¦ãƒ»æ¨ªç§»å‹•ï¼‰
      const opp = OPPONENTS[currentStage];
      const cpuCenterY = cpu.y + PADDLE_H / 2;
      const dyDiff = ball.y - cpuCenterY;
      const vertSpeed = Math.min(Math.abs(dyDiff), opp.speed);
      cpu.y += Math.sign(dyDiff) * vertSpeed;
      cpu.y = clamp(cpu.y, 0, H - PADDLE_H);

      // æ¨ªç§»å‹•ï¼ˆfreedom > 0 ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã¿ï¼‰
      if (opp.freedom > 0) {
        const baseX = W - 20 - PADDLE_W;
        // ãƒœãƒ¼ãƒ«ãŒå³ã«æ¥ã‚‹ã¨ãå‰é€²ã€å·¦ã«è¡Œãã¨ãå¾Œé€€
        const targetX = ball.vx > 0
          ? clamp(ball.x - PADDLE_W * 3, W / 2, baseX)
          : baseX;
        const hdiff = targetX - cpu.x;
        const horizSpeed = opp.freedom * opp.speed * 0.5;
        cpu.x += clamp(hdiff, -horizSpeed, horizSpeed);
        cpu.x = clamp(cpu.x, W / 2, W - PADDLE_W - 5);
      }

      // ãƒœãƒ¼ãƒ«è»Œè·¡
      ball.trail.push({ x: ball.x, y: ball.y });
      if (ball.trail.length > 10) ball.trail.shift();

      // ãƒœãƒ¼ãƒ«ç§»å‹•
      ball.x += ball.vx;
      ball.y += ball.vy;

      // ä¸Šä¸‹å£åå°„
      if (ball.y - BALL_R < 0) {
        ball.y = BALL_R;
        ball.vy = Math.abs(ball.vy);
      }
      if (ball.y + BALL_R > H) {
        ball.y = H - BALL_R;
        ball.vy = -Math.abs(ball.vy);
      }

      // ãƒ‘ãƒ‰ãƒ«è¡çª
      if (hitPaddle(ball, player) && ball.vx < 0) {
        ball.vx = Math.abs(ball.vx) * 1.13;
        ball.vy += (ball.y - (player.y + PADDLE_H / 2)) * 0.1;
        ball.vx = clamp(ball.vx, 4, 18);
        ball.vy = clamp(ball.vy, -12, 12);
        ball.x = player.x + PADDLE_W + BALL_R;
      }
      if (hitPaddle(ball, cpu) && ball.vx > 0) {
        ball.vx = -Math.abs(ball.vx) * 1.13;
        ball.vy += (ball.y - (cpu.y + PADDLE_H / 2)) * 0.1;
        ball.vx = clamp(ball.vx, -18, -4);
        ball.vy = clamp(ball.vy, -12, 12);
        ball.x = cpu.x - BALL_R;
      }

      // å¾—ç‚¹åˆ¤å®š
      if (ball.x - BALL_R < 0) {
        scores.cpu++;
        endPoint('cpu');
      } else if (ball.x + BALL_R > W) {
        scores.player++;
        endPoint('player');
      }
    }

    function hitPaddle(b, p) {
      return b.x - BALL_R < p.x + p.w &&
             b.x + BALL_R > p.x &&
             b.y - BALL_R < p.y + p.h &&
             b.y + BALL_R > p.y;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function endPoint(scorer) {
      state = 'point';
      if (scores.player >= WIN_SCORE) {
        if (currentStage >= OPPONENTS.length - 1) {
          state = 'allclear';
          msg.textContent = 'å…¨ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¶è¦‡ï¼  SPACE ã§ã‚¿ã‚¤ãƒˆãƒ«ã¸';
        } else {
          state = 'stageclear';
          const next = OPPONENTS[currentStage + 1];
          msg.textContent = `STAGE ${currentStage + 1} CLEAR!  æ¬¡ã®ç›¸æ‰‹: ${next.emoji} ${next.name}  SPACE ã§ç¶šã‘ã‚‹`;
        }
      } else if (scores.cpu >= WIN_SCORE) {
        state = 'gameover';
        msg.textContent = `GAME OVER...  SPACE ã§ãƒªãƒˆãƒ©ã‚¤`;
      } else {
        msg.textContent = scorer === 'player' ? 'ãƒã‚¤ãƒ³ãƒˆç²å¾—ï¼' : 'CPUã®ãƒã‚¤ãƒ³ãƒˆ';
        setTimeout(() => {
          resetRound(scorer);
          state = 'playing';
          msg.textContent = '';
        }, 1200);
      }
    }

    // --- ãƒ«ãƒ¼ãƒ— ---
    function loop() {
      update();
      draw();

      // åœæ­¢çŠ¶æ…‹ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
      if (state === 'idle' || state === 'gameover' || state === 'stageclear' || state === 'allclear') {
        drawOverlay();
      }

      requestAnimationFrame(loop);
    }

    function drawOverlay() {
      ctx.fillStyle = 'rgba(22,33,62,0.55)';
      ctx.fillRect(0, 0, W, H);
    }

    // --- ã‚­ãƒ¼å…¥åŠ› ---
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') {
        e.preventDefault();
        startOrRestart();
      }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function startOrRestart() {
      if (state === 'idle') {
        resetRound(null);
        state = 'playing';
        msg.textContent = '';
      } else if (state === 'stageclear') {
        currentStage++;
        scores = { player: 0, cpu: 0 };
        resetRound(null);
        state = 'playing';
        msg.textContent = '';
      } else if (state === 'gameover') {
        // åŒã˜ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ãƒªãƒˆãƒ©ã‚¤
        scores = { player: 0, cpu: 0 };
        resetRound(null);
        state = 'playing';
        msg.textContent = '';
      } else if (state === 'allclear') {
        resetGame();
      }
    }

    // --- ãƒã‚¦ã‚¹è¿½å¾“ ---
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mouseX = (e.clientX - rect.left) * scaleX;
      const mouseY = (e.clientY - rect.top) * scaleY;
      // å·¦åŠã‚³ãƒ¼ãƒˆå†…ã«ãƒã‚¦ã‚¹ãŒã‚ã‚‹æ™‚ã ã‘æ›´æ–°ï¼ˆå³åŠã§ã¯æ›´æ–°ã—ãªã„ï¼‰
      if (mouseX <= W / 2) {
        player.x = clamp(mouseX - PADDLE_W / 2, 5, W / 2 - PADDLE_W);
        player.y = clamp(mouseY - PADDLE_H / 2, 0, H - PADDLE_H);
      }
    });

    // --- ã‚¿ãƒƒãƒæ“ä½œ ---
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã‚¿ãƒƒãƒ: æŒ‡ã®ä½ç½®ã«ãƒ‘ãƒ‰ãƒ«ã‚’è¿½å¾“
    let touchPos = null;

    function getCanvasPos(touch) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      return {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      startOrRestart();
      touchPos = getCanvasPos(e.touches[0]);
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      touchPos = getCanvasPos(e.touches[0]);
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      touchPos = null;
    }, { passive: false });

    // â–²â–¼ ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç”¨ï¼‰
    const btnUp   = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');

    function addButtonTouch(btn, keyName) {
      btn.addEventListener('touchstart', e => {
        e.preventDefault();
        keys[keyName] = true;
        startOrRestart();
      }, { passive: false });
      btn.addEventListener('touchend', e => {
        e.preventDefault();
        keys[keyName] = false;
      }, { passive: false });
      btn.addEventListener('mousedown', () => { keys[keyName] = true; startOrRestart(); });
      btn.addEventListener('mouseup',   () => { keys[keyName] = false; });
    }
    addButtonTouch(btnUp,   'ArrowUp');
    addButtonTouch(btnDown, 'ArrowDown');

    // --- èµ·å‹• ---
    resetGame();
    loop();
  </script>
</body>
</html>
